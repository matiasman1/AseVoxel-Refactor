-- utils/file_utils.lua (moved from fileUtils.lua; unchanged API; short helpers only)
local M = {}
local previewRenderer

local function getRenderer()
  if not previewRenderer then previewRenderer = require("render.previewRenderer") end
  return previewRenderer
end

function M.exportGeneric(voxels, filePath, options)
  options = options or {}
  local format = (options.format or app.fs.fileExtension(filePath)):lower()
  if not filePath:lower():match("%."..format.."$") then filePath = filePath .. "." .. format end
  if format == "obj" then return getRenderer().exportOBJ(voxels, filePath, options)
  elseif format == "ply" then return M.exportPLY(voxels, filePath, options)
  elseif format == "stl" then return M.exportSTL(voxels, filePath, options)
  else
    app.alert("Unsupported export format '"..format.."'. Using OBJ instead.")
    return getRenderer().exportOBJ(voxels, filePath:gsub("%.[^%.]+$", ".obj"), options)
  end
end

function M.exportPLY(voxels, filePath, options)
  options = options or {}
  local s = options.scaleModel or 1.0
  if not filePath:lower():match("%.ply$") then filePath = filePath .. ".ply" end
  local f = io.open(filePath, "w"); if not f then return false end
  local minY,maxY=math.huge,-math.huge
  for _,v in ipairs(voxels) do if v.y<minY then minY=v.y end; if v.y>maxY then maxY=v.y end end
  local span = maxY - minY
  local nV, nF = #voxels*8, #voxels*12
  f:write("ply\nformat ascii 1.0\ncomment Generated by AseVoxel\n")
  f:write("element vertex "..nV.."\nproperty float x\nproperty float y\nproperty float z\n")
  f:write("property uchar red\nproperty uchar green\nproperty uchar blue\n")
  f:write("element face "..nF.."\nproperty list uchar int vertex_index\nend_header\n")
  local vi=0
  for _,voxel in ipairs(voxels) do
    local x = voxel.x*s; local invY = (span - (voxel.y - minY)) + minY; local y=invY*s; local z=voxel.z*s; local size=s
    local verts={{x,y,z},{x+size,y,z},{x+size,y,z+size},{x,y,z+size},{x,y+size,z},{x+size,y+size,z},{x+size,y+size,z+size},{x,y+size,z+size}}
    local r,g,b=voxel.color.r,voxel.color.g,voxel.color.b
    for _,vv in ipairs(verts) do f:write(string.format("%f %f %f %d %d %d\n", vv[1],vv[2],vv[3], r,g,b)) end
    vi=vi+8
  end
  vi=0
  for _ in ipairs(voxels) do
    local b=vi
    local faces={{b,b+1,b+2},{b+2,b+3,b},{b+4,b+7,b+6},{b+6,b+5,b+4},
                 {b+3,b+2,b+6},{b+6,b+7,b+3},{b,b+4,b+5},{b+5,b+1,b},
                 {b,b+3,b+7},{b+7,b+4,b},{b+2,b+1,b+5},{b+5,b+6,b+2}}
    for _,t in ipairs(faces) do f:write(string.format("3 %d %d %d\n", t[1],t[2],t[3])) end
    vi=vi+8
  end
  f:close(); return true
end

function M.exportSTL(voxels, filePath, options)
  options = options or {}
  local s = options.scaleModel or 1.0
  if not filePath:lower():match("%.stl$") then filePath = filePath .. ".stl" end
  local minY,maxY=math.huge,-math.huge
  for _,v in ipairs(voxels) do if v.y<minY then minY=v.y end; if v.y>maxY then maxY=v.y end end
  local span = maxY - minY
  local f = io.open(filePath, "w"); if not f then return false end
  f:write("solid voxelmodel\n")
  for _,voxel in ipairs(voxels) do
    local x=voxel.x*s; local invY=(span-(voxel.y-minY))+minY; local y=invY*s; local z=voxel.z*s; local size=s
    local v1={x,y,z}; local v2={x+size,y,z}; local v3={x+size,y,z+size}; local v4={x,y,z+size}
    local v5={x,y+size,z}; local v6={x+size,y+size,z}; local v7={x+size,y+size,z+size}; local v8={x,y+size,z+size}
    local tris={{v1,v2,v3,{0,-1,0}},{v3,v4,v1,{0,-1,0}},{v5,v8,v7,{0,1,0}},{v7,v6,v5,{0,1,0}},
                {v4,v3,v7,{0,0,1}},{v7,v8,v4,{0,0,1}},{v1,v5,v6,{0,0,-1}},{v6,v2,v1,{0,0,-1}},
                {v1,v4,v8,{-1,0,0}},{v8,v5,v1,{-1,0,0}},{v3,v2,v6,{1,0,0}},{v6,v7,v3,{1,0,0}}}
    for _,t in ipairs(tris) do
      local n=t[4]; f:write(string.format("  facet normal %.6f %.6f %.6f\n", n[1],n[2],n[3]))
      f:write("    outer loop\n")
      for i=1,3 do f:write(string.format("      vertex %.6f %.6f %.6f\n", t[i][1],t[i][2],t[i][3])) end
      f:write("    endloop\n  endfacet\n")
    end
  end
  f:write("endsolid voxelmodel\n"); f:close(); return true
end

-- Thin wrappers for app.fs functions
M.joinPath          = function(...) return app.fs.joinPath(...) end
M.getFileExtension  = function(p) return app.fs.fileExtension(p) end
M.getFileName       = function(p) return app.fs.fileName(p) end
M.getFileTitle      = function(p) return app.fs.fileTitle(p) end
M.getDirectory      = function(p) return app.fs.filePath(p) end
M.isDirectory       = function(p) return app.fs.isDirectory(p) end
M.isFile            = function(p) return app.fs.isFile(p) end
M.listFiles         = function(p) return app.fs.listFiles(p) end
M.createDirectory   = function(p) return app.fs.makeDirectory(p) end
M.createDirectories = function(p) return app.fs.makeAllDirectories(p) end

return M